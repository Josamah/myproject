<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title></title>
  <meta content="" name="description">
  <meta content="width=device-width, initial-scale=1" name="viewport">

  <meta content="" property="og:title">
  <meta content="" property="og:type">
  <meta content="" property="og:url">
  <meta content="" property="og:image">

  <link href="../site.webmanifest" rel="manifest">
  <link href="../icon.png" rel="apple-touch-icon">
  <!-- Place favicon.ico in the root directory -->

  <link href="css/normalize.css" rel="stylesheet">
  <link href="css/main.css" rel="stylesheet">

  <meta content="#fafafa" name="theme-color">
</head>

<body>

<!-- Add your site or application content here -->
<div id="wrapper" class="margin_left_right_auto">
  <div id="header">
    <div id="logo" class="gr_width_small float_left">
      <a href="index.html"><img src="img/img_8.png" height="120" width="369"></a>
    </div>
    <div id="menu" class="gr_width_large float_left">
      <menu class="float_right reset_margin_padding">
        <li><a href="index.html">pylint</a></li>
        <li><a href="AAA testing.html">AAA testing</a></li>
        <li><a href="OOPs.html">OOPS</a></li>
        <li><a href="SOLID Object Oriented Design.html">SOLID Objected Oriented Design</a></li>
      </menu>
    </div>
    <div id="masthead" class="clear_float mastheadTopMargin">
    </div>
  </div>
  <div id="main">
    <div id="content" class="float_left gr_width_large">
      <div id="article_title">
        <h1 class="reset_margin_padding">SOLID Object Oriented Design</h1>
      </div>
      <div id="article_body">
        <p>
          Object Oriented Programming
        </p>
        <p>
          SOLID is a mnemonic abbreviation for a set of design principles created for software development in object-oriented languages. The principles in SOLID are intended to foster simpler, more robust and updatable code from software developers. Each letter in SOLID corresponds to a principle for development:
        </p>
        <p>
          When implemented properly it makes your code more extendable, logical and easier to read.
        </p>
        <p>
          To understand SOLID principles, you have to know the use of the interface clearly.
        </p>
        <p>
          I’m going to try to explain SOLID Principles in Python in simplest way so that it’s easy for beginners to understand. It would be very easy to just take the examples provided and apply them to Python.
        </p>
        <p>
          1. Single Responsibility Principle
        </p>
        <p>
          The Single Responsibility Principle requires that a class should have only one job. So if a class has more than one responsibility, it becomes coupled. A change to one responsibility results to modification of the other responsibility.
        </p>
        <p>
        <div class="colored_div">
          1  #Below is Given a class which has two responsibilities
          2  class  User:
          3  def __init__(self, name: str):
          4  self.name = name
          5
          6  def get_name(self) -> str:
          7  pass
          8
          9  def save(self, user: User):
          10 pass
        </div>
        </p>
        <p>
          We have a User class which is responsible for both the user properties and user database management. If the application changes in a way that it affect database management functions. The classes that make use of User properties will have to be touched and recompiled to compensate for the new changes. It’s like a domino effect, touch one card it affects all other cards in line.
        </p>
        <p>
          So we simply split the class, we create another class that will handle the one responsibility of storing an user to a database:
        </p>
        <p>
        <div class="colored_div">
          1  class User:
          2  def __init__(self, name: str):
          3  self.name = name
          4
          5  def get_name(self):
          6  pass
          7
          8
          9  class UserDB:
          10 def get_user(self, id) -> User:
          11 pass
          12
          13 def save(self, user: User):
          14 pass
        </div>
        </p>
        <p>
          A common solution to this dilemma is to apply the Façade pattern. For introduction to Façade pattern you can read more. User class will be the Facade for user database management and user properties management.
        </p>
        <p>
          2. Open-Closed Principle
        </p>
        <p>
          Software entities(Classes, modules, functions) should be open for extension, not modification.
        </p>
        <p>
          Let’s imagine you have a store, and you give a discount of 20% to your favorite customers using this class: When you decide to offer double the 20% discount to VIP customers. You may modify the class like this:
        </p>
        <p>
        <div class="colored_div">
          1  class Discount:
          2  def __init__(self, customer, price):
          3  self.customer = customer
          4  self.price = price
          5  def give_discount(self):
          6  if self.customer == 'fav':
          7  return self.price * 0.2
          8  if self.customer == 'vip':
          9  return self.price * 0.4
         </div>
        </p>
        <p>
          No, this fails the OCP principle. OCP forbids it. If we want to give a new percent discount maybe, to a different type of customers, you will see that a new logic will be added. To make it follow the OCP principle, we will add a new class that will extend the Discount. In this new class, we would implement its new behavior:
        </p>
        <p>
        <div class="colored_div">
          1  class Discount:
          2  def __init__(self, customer, price):
          3  self.customer = customer
          4  self.price = price
          5  def get_discount(self):
          6  return self.price * 0.2
          7  class VIPDiscount(Discount):
          8  def get_discount(self):
          9  return super().get_discount() * 2
        </div>
        </p>
        <p>
          3. Liskov Substitution Principle
        </p>
        <p>
          The main idea behind Liskov Subtitution Principle is that, for any class, a client should be able to use any of its subtypes indistinguishably, without even noticing, and therefore without compromising the expected behavior at runtime. This means that clients are completely isolated and unaware of changes in the class hierarchy.
        </p>
        <p>
          More formally:
          Let q(x) be a property provable about objects of x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.
        </p>
        <p>
          In simpler terms means that a subclass, child or specialization of an object or class must be suitable by its Parent or SuperClass.
        </p>
        <p>
        <div class="colored_div">
          1  class User():
          2  def __init__(self, color, board):
          3  create_pieces()
          4  self.color = color
          5  self.board = board
          6  def move(self, piece:Piece, position:int):
          7  piece.move(position)
          8  chessmate_check()
          9  board = ChessBoard()
          10 user_white = User("white", board)
          11 user_black = User("black", board)
          12 pieces = user_white.pieces
          13 horse = helper.getHorse(user_white, 1)
          14 user.move(horse)
        </div>
        </p>
        <p>
          Remarks on the LSP The LSP is fundamental to a good object-oriented software design because it emphasizes one of its core traits — polymorphism. It is about creating correct hierarchies so that classes derived from a base one are polymorphic along the parent one, with respect to the methods on their interface. It is also interesting to notice how this principle relates to the previous one — if we attempt to extend a class with a new one that is incompatible, it will fail, the contract with the client will be broken, and as a result such an extension will not be possible (or, to make it possible, we would have to break the other end of the principle and modify code in the client that should be closed for modification, which is completely undesirable and unacceptable).
        </p>
        <p>
          Carefully thinking about new classes in the way that LSP suggests helps us to extend the hierarchy correctly. We could then say that LSP contributes to the OCP.
        </p>
        <p>
          4. Interface Segregation Principle
        </p>
        <p>
          Make fine grained interfaces that are client specific Clients should not be forced to depend upon interfaces that they do not use. This principle deals with the disadvantages of implementing big interfaces.
        </p>
        <p>
        <div class="colored_div">
          To illustrate this completely, we will go with a classic example because it is highly significant and easily understandable. The Classic Example
          1
          2  class IShape:
          3  def draw(self):
          4  raise NotImplementedError
          5
          6  class Circle(IShape):
          7  def draw(self):
          8  pass
          9
          10 class Square(IShape):
          11 def draw(self):
          12 pass
          13
          14 class Rectangle(IShape):
          15 def draw(self):
          16 pass
          Another nice trick is that in our business logic, a single class can implement several interfaces if needed. So we can provide a single implementation for all the common methods between the interfaces. The segregated interfaces will also force us to think of our code more from the client’s point of view, which will in turn lead to loose coupling and easy testing. So, not only have we made our code better to our clients, we also made it easier for ourselves to understand, test and implement.
         </div>
        </p>
        <p>
          5. Dependecy Inversion Principle
        </p>
        <p>
          Dependency should be on abstractions not concretions. High-level modules should not depend upon low-level modules. Both low and high level classes should depend on the same abstractions. Abstractions should not depend on details. Details should depend upon abstractions.
        </p>
        <p>
          There comes a point in software development where our app will be largely composed of modules. When this happens, we have to clear things up by using dependency injection. High-level components depending on low-level components to function. To create specific behavior you can use techniques like inheritance or interfaces.
        </p>
        <p>
        <div class="colored_div">
          1  class AuthenticationForUser():
          2  def __init__(self, connector:Connector):
          3  self.connection = connector.connect()
          4
          5  def authenticate(self, credentials):
          6  pass
          7  def is_authenticated(self):
          8  pass
          9  def last_login(self):
          10 pass
          11
          12 class AnonymousAuth(AuthenticationForUser):
          13 pass
          14
          15 class GithubAuth(AuthenticationForUser):
          16 def last_login(self):
          17 pass
          18
          19 class FacebookAuth(AuthenticationForUser):
          20 pass
          21
          22 class Permissions()
          23 def __init__(self, auth: AuthenticationForUser)
          24 self.auth = auth
          25
          26 def has_permissions():
          27 pass
          28
          29 class IsLoggedInPermissions (Permissions):
          30 def last_login():
          31 return auth.last_log
      </div>
        </p>
        </p>


      </div>
    </div>
    <div id="sidebar" class="float_left gr_width_small">
      <div id="side_photo" class="margin_left_right_auto">
        <img src="img/img_4.png" height="346" width="320">
      </div>
    </div>
  </div>
  <div id="footer" class="clear_float text_center">
    © Joshua Samah
    <script type="text/javascript">
      var d= new Date()
      document.write(d.getFullYear())

    </script>
    <a href="http://validator.w3.org/check/referer"><img src="https://www.w3.org/Icons/valid-html401-blue"></img></a>
  </div>
</div>

<script src="../js/vendor/modernizr-3.11.2.min.js"></script>
<script src="../js/plugins.js"></script>
<script src="../js/main.js"></script>

<!-- Google Analytics: change UA-XXXXX-Y to be your site's ID. -->
<script>
  window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
  ga('create', 'UA-XXXXX-Y', 'auto'); ga('set', 'anonymizeIp', true); ga('set', 'transport', 'beacon'); ga('send', 'pageview')
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
</body>

</html>
